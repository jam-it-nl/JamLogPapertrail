// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package jamlogpapertrail.actions;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.net.URL;
import org.productivity.java.syslog4j.SyslogConfigIF;
import org.productivity.java.syslog4j.SyslogIF;
import org.productivity.java.syslog4j.SyslogRuntimeException;
import org.productivity.java.syslog4j.impl.net.tcp.ssl.SSLTCPNetSyslogConfig;
import com.mendix.core.Core;
import com.mendix.logging.ILogNode;
import com.mendix.logging.LogLevel;
import com.mendix.logging.LogMessage;
import com.mendix.logging.LogSubscriber;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import jamlogpapertrail.proxies.constants.Constants;

public class RegisterLogSubscriber extends CustomJavaAction<java.lang.Void>
{
	private java.lang.String papertrailHost;
	private java.lang.Long papertrailPort;
	private java.lang.String logLevel;

	public RegisterLogSubscriber(IContext context, java.lang.String papertrailHost, java.lang.Long papertrailPort, java.lang.String logLevel)
	{
		super(context);
		this.papertrailHost = papertrailHost;
		this.papertrailPort = papertrailPort;
		this.logLevel = logLevel;
	}

	@java.lang.Override
	public java.lang.Void executeAction() throws Exception
	{
		// BEGIN USER CODE
		String applicationRootUrl = Core.getConfiguration().getApplicationRootUrl();
		URL url = new URL(applicationRootUrl);

		if (!Constants.getEnableOnLocalhost() && url.getHost().equals("localhost")) {
			return null;
		}

		SyslogConfigIF config = new SSLTCPNetSyslogConfig();
		config.setHost(this.papertrailHost);
		config.setPort(this.papertrailPort.intValue());
		config.setIdent(url.getHost());

		LogLevel mendixLogLevel = LogLevel.valueOf(this.logLevel);

		Core.registerLogSubscriber(new MendixObjectLogSubscriber(mendixLogLevel, config));
		Core.getLogger("JamLogPapertrail").warn("Registered Papertrail logger on level " + this.logLevel);
		return null;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "RegisterLogSubscriber";
	}

	// BEGIN EXTRA CODE
	private class MendixObjectLogSubscriber extends LogSubscriber {
		private SyslogIF syslog;

		public MendixObjectLogSubscriber(LogLevel logLevel, SyslogConfigIF syslogConfig) {
			super(MendixObjectLogSubscriber.class.getName(), logLevel);
			synchronized (this) {
				try {
					Class<?> syslogClass = syslogConfig.getSyslogClass();
					syslog = (SyslogIF) syslogClass.getDeclaredConstructor().newInstance();
					syslog.initialize(syslogClass.getSimpleName(), syslogConfig);
				} catch (Exception cse) {
					throw new SyslogRuntimeException(cse);
				}
			}
		}

		private int getSysLogLevel(LogLevel logLevel) {
			// 0 Emergency Panic: The network is useless.
			// 1 Alert Something bad happened, deal with it NOW!
			// 2 Critical Something bad is about to happen, deal with it NOW!
			// 3 Error A failure in the system that needs attention.
			// 4 Warning Something will happen if it is not dealt within a timeframe.
			// 5 Notification Normal but significant conditions.
			// 6 Informational Informative but not important.
			// 7 Debugging Lots of unnecessary messages. Only relevant for developers

			switch (logLevel) {
			case CRITICAL:
				return SyslogIF.LEVEL_CRITICAL;
			case DEBUG:
				return SyslogIF.LEVEL_INFO;
			case ERROR:
				return SyslogIF.LEVEL_ERROR;
			case INFO:
				return SyslogIF.LEVEL_NOTICE;
			case NONE:
				return SyslogIF.LEVEL_EMERGENCY;
			case TRACE:
				return SyslogIF.LEVEL_DEBUG;
			case WARNING:
				return 4;
			default:
				return SyslogIF.LEVEL_EMERGENCY;
			}
		}

		@Override
		public void processMessage(LogMessage logMessage) {
			if (logMessage.node != null && logMessage.node.name() != null) {
				if (logMessage.node.name().equals("Connector")) {
					return;
				}
			}

			String message = String.format("[%s] [%s] %s", convertLevel(logMessage), convertNode(logMessage.node), convertMessage(logMessage.message));
			syslog.log(this.getSysLogLevel(logMessage.level), message);
		}

		private String convertLevel(LogMessage logMessage) {
			if (logMessage == null) {
				return "";
			}

			if (logMessage.level == null) {
				return "";
			}

			return logMessage.level.toString();
		}

		private String convertNode(ILogNode node) {
			if (node == null) {
				return "";
			}
			final String nodeName = node.name();
			if ((nodeName != null) && (nodeName.length() > 128)) {
				return nodeName.substring(0, 128);
			}
			return nodeName;
		}

		private String convertMessage(Object message) {
			if (message == null) {
				return "";
			}
			return message.toString();
		}

		private String convertCause(Throwable cause) {
			if (cause == null) {
				return "";
			}
			final Writer stringWriter = new StringWriter();
			cause.printStackTrace(new PrintWriter(stringWriter));
			return stringWriter.toString();
		}
	}

	// END EXTRA CODE
}
